<!DOCTYPE html>
<html>
  <head>
    <title>Game Object Test</title>
    <style>
      body {
        background-color: rgb(53, 53, 53);
      }
      main {
        display: flex;
        height: 100vh;
        width: 50vh;
        justify-content: center;
        align-items: center;
      }
      .game-board {
        display: flex;
        flex-wrap: wrap;
        background-color: gray;
        width: 100%;
      }
      .cell {
        box-sizing: border-box;
        background-color: lightgray;
        border: 1px solid black;
        height: 10vh;
      }
      .slot {
        width: 100%;
        height: 100%;
      }
      .fox-piece {
        background-color: red;
      }
      .falco-piece {
        background-color: blue;
      }
    </style>
  </head>
  <body>
    <main></main>
    <script>
      const EMPTY = -1;

      class Gameboard {
        element;
        grid;
        players;
        piecesToWin;
        currentPlayer;
        pieces;
        constructor(gridX, gridY, piecesToWin, players) {
          this.players = players;
          this.currentPlayer = 0;
          this.piecesToWin = piecesToWin;
          this.pieces = [
            "fox-piece",
            "falco-piece",
            "slippy-piece",
            "krystal-piece",
            "andross-piece",
            "peppy-piece"
          ];
          this.pieces.length = players;
          this.element = document.querySelector("main").appendChild(document.createElement("div"));
          this.element.classList.add("container", "game-board");
          this.element.addEventListener("click", e => this.onClick(e));
          this.initializeGrid(gridX, gridY);
        }
        initializeGrid(gridX, gridY) {
          let currentElement = this.element;

          this.grid = [];
          // currentElement.setAttribute("style",
                                      // `height: ${100 * gridY / gridX}%;`);
                                    // + `width: ${100* gridX / gridY }%`);
          for(let x = 0; x < gridX; ++x) {
            this.grid.push([]);
            for(let y = 0; y < gridY; ++y) {
              currentElement = document.createElement("div");
              this.grid[x].push(currentElement);
              this.element.appendChild(currentElement);
              currentElement.classList.add("container", "cell");
              currentElement.setAttribute("style",
                                          `flex-basis: ${100 / gridY}%;`
                                        + `height: ${100 / gridX}vh;`
              );
              currentElement.setAttribute("data-col", y);
              currentElement.setAttribute("data-row", x);
              currentElement = currentElement.appendChild(document.createElement("div"));
              currentElement.classList.add("slot", "empty");
              currentElement.setAttribute("value", EMPTY);
            }
          }
        }
        incrementPlayer(player) {
          switch(player) {
            case "current":
              this.currentPlayer = (this.currentPlayer + 1) % this.players;
              return this.currentPlayer;
            default:
              return null;
          }
        }

        onClick(e) {
          let target = e.target;
          if(target.classList.contains("slot"))
            target = target.parentElement;
          if(target.classList.contains("cell"))
            if(this.setSlot(target, this.currentPlayer))
              if(this.checkWin(target))
                ; // call win sequence
              else
                this.incrementPlayer("current");
        }
        checkWin(target) {
          this.checkWinAt(this.getCellX(target), this.getCellY(target));
        }
        checkWinAt(x, y) {
          return checkAdjacent(x, y);
        }
        checkAdjacent(x, y) {
          let count = 1;
          let highestCount = 1;
//reset counts n stuff
          count += checkDirection(x, y, -1, 1); // left up
          count += checkDirection(x, y, 1, -1); // right down

          count += checkDirection(x, y, 1, 1);  // right up
          count += checkDirection(x, y, -1, -1);// left down

          return count >= this.piecesToWin;
        }
        checkDirection(x1, y1, xDir, yDir) {
          const x2 = x1 + xDir;
          const y2 = y1 + yDir;

          if(x2 >= 0 && y2 >= 0 && x2 < this.grid.length && y2 < this.grid[0].length )
            if(this.grid[x1][y1] == this.grid[x2][y2])
              return 1 + this.checkDirection(x2, y2, xDir, yDir);
          return 0;
        }
        updateSlot(slot) {
          return slot.classList.replace(slot.classList.item(1), this.pieces[Number(slot.getAttribute("value"))]);
        }
        setSlot(target, value, force = false) {
          return this.setSlotAt(this.getCellX(target), this.getCellY(target), value, force);
        }
        setSlotAt(x, y, value, force = false) {
          const slot = this.grid[x][y].firstElementChild;

          if(force || this.getSlotValue(x, y) === EMPTY) {
            slot.setAttribute("value", value);
            return this.updateSlot(slot);
          }
          return false;
        }
        compareSlots(x1, y1, x2, y2) {
          return this.getSlotValue(x1, y1) === this.getSlotValue(x2, y2);
        }
        getSlotValue(x, y) {
          return Number(this.getCell(x, y).firstElementChild.getAttribute("value"));
        }
        getCell(x, y) {
          return this.grid[x][y];
        }
        getCellPos(target) {
          return {x: this.getCellX(target), y: this.getCellY(target)};
        }
        getCellY(target) {
          return Number(target.getAttribute("data-col"));
        }
        getCellX(target) {
          return Number(target.getAttribute("data-row"));
        }
      };

      var a = new Gameboard(7, 6, 2);
    </script>
    <script>

    </script>
  </body>
</html>
