<!DOCTYPE html>
<html>
  <head>
    <title>Game Object Test</title>
    <style>
      body {
        background-color: rgb(53, 53, 53);
      }
      main {
        display: flex;
        height: 100vh;
        width: 100%;
        justify-content: center;
        align-items: center;
      }
      .game-board {
        display: flex;
        flex-wrap: wrap;
        background-color: gray;
        width: 50%;
        height: 50%;
      }
      .cell {
        box-sizing: border-box;
        background-color: lightgray;
        border: 1px solid black;
        height: 10vh;
      }
      .slot {
        width: 100%;
        height: 100%;
      }
      .fox-piece {
        background-color: red;
      }
      .falco-piece {
        background-color: blue;
      }
      .slippy-piece {
        background-color: green;
      }
      .krystal-piece {
        background-color: purple;
      }
      .andross-piece {
        background-color: yellow;
      }
      .peppy-piece {
        background-color: orange;
      }
    </style>
  </head>
  <body>
    <main></main>
    <script>
      const EMPTY = -1;

      class Scoreboard {
        gameboard;
        players;
        scores;
        timeLimit;
        currentTime;
        paused;
        constructor(gameboard, players, timeLimit = 0){
          this.scores = [];
          this.players = [];
          this.scores.length = players;
          this.scores = this.scores.fill(0);
          this.paused = true;
          for(let player = 0; player < players.length; ++player)
            players[player] = `Player ${player + 1}`;
          this.setTimeLimit(timeLimit);
          setInterval(()=>this.decrementTime(), 1000);
          this.gameboard = gameboard;
        }

        togglePause() {
          return this.paused = !this.paused;
        }

        setTimeLimit(time) {
          this.timeLimit = time;
          this.resetTime();
          return this.timeLimit;
        }

        resetTime() {
          return this.currentTime = this.timeLimit;
        }

        decrementTime() {
          if(!this.paused && this.timeLimit > 0) {
            console.log(this.currentTime);
            --this.currentTime;
            if (this.currentTime < 0) {
              this.gameboard.incrementPlayer("current");
              this.resetTime();
            }
          }
          return this.currentTime;
        }
      }

      class Gameboard {
        element;
        scoreboard;
        grid;
        players;
        piecesToWin;
        currentPlayer;
        pieces;
        constructor(gridX = 7, gridY = 6, piecesToWin = 4, players = 2) {
          const main = document.querySelector("main");
          this.scoreboard = new Scoreboard(this, players);
          this.players = players;
          this.currentPlayer = 0;
          this.piecesToWin = piecesToWin;
          this.pieces = [
            "fox-piece",
            "falco-piece",
            "slippy-piece",
            "krystal-piece",
            "andross-piece",
            "peppy-piece"
          ];
          main.innerHTML = "";
          this.element = main.appendChild(document.createElement("div"));
          this.element.classList.add("container", "game-board");
          this.element.addEventListener("click", e => this.onClick(e));
          this.initializeGrid(gridX, gridY);
        }
        initializeGrid(gridX, gridY) {
          let currentElement = this.element;

          this.grid = [];
          // currentElement.setAttribute("style",
                                      // `height: ${100 * gridY / gridX}%;`);
                                    // + `width: ${100* gridX / gridY }%`);
          for(let y = 0; y < gridY; ++y) {
            this.grid.push([]);
            for(let x = 0; x < gridX; ++x) {
              currentElement = document.createElement("div");
              this.grid[y].push(currentElement);
              currentElement.classList.add("container", "cell");
              currentElement.setAttribute("style",
                                          `flex-basis: ${100 / gridX}%;`
                                        + `height: ${100 / gridY}%;`
              );
              currentElement.setAttribute("data-col", x);
              currentElement.setAttribute("data-row", y);
              currentElement = currentElement.appendChild(document.createElement("div"));
              currentElement.classList.add("slot", "empty");
              currentElement.setAttribute("value", EMPTY);
            }
          }

          // ensure grid builds with row number descending
          for(let y = gridY - 1; y >= 0; --y)
            for(let x = 0; x < gridX; ++x)
              this.element.appendChild(this.grid[y][x]);
        }

        // misc handlers
        createScoreBoard(players, timeLimit) {
          this.scoreboard = new Scoreboard(players, timeLimit);
        }



        incrementPlayer(player) {
          switch(player) {
            case "current":
              this.currentPlayer = (this.currentPlayer + 1) % this.players;
              return this.currentPlayer;
            default:
              return null;
          }
        }

        win() {
          console.log(`Player ${this.currentPlayer + 1} wins`);
        }

        // element handlers
        onClick(e) {
          let target = e.target;
          if(target.classList.contains("slot"))
            target = target.parentElement;
          if(target.classList.contains("cell"))
            if(this.pushToSlot(target, this.currentPlayer))
              this.incrementPlayer("current");
        }

        checkWin(target) {
          return this.checkWinAt(this.getCellX(target), this.getCellY(target));
        }
        pushToSlot(target, value) {
          return this.pushToSlotAt(this.getCellX(target), value);
        }
        setSlot(target, value, force = false) {
          return this.setSlotAt(this.getCellX(target), this.getCellY(target), value, force);
        }
        updateSlot(slot) {
          return slot.classList.replace(slot.classList.item(1), this.pieces[Number(slot.getAttribute("value"))]);
        }
        getCellY(cell) {
          return Number(cell.getAttribute("data-row"));
        }
        getCellX(cell) {
          return Number(cell.getAttribute("data-col"));
        }

        // grid handlers
        refreshSlots() {
          for(let y = 0; y < this.grid.length; ++y)
            for(let x = 0; x < this.grid[0].length; ++x)
              updateSlot(this.getSlotAt(x, y));
        }
        pushToSlotAt(x, value) {
          let y = 0;
          while(y < this.grid.length) {
            if (this.setSlotAt(x, y, value)) {
              if (this.checkWinAt(x, y))
                this.win();
              return true;
            }
            ++y;
          }
          return false;
        }
        checkWinAt(x, y) {
          return this.checkAdjacent(x, y);
        }
        checkAdjacent(x, y) {
          let count = 1;
          let highestCount = 1;
          function compareAndReset() {
            if(count > highestCount)
              highestCount = count;
            count = 1;
          }
          // negative slant
          count += this.checkDirectionAt(x, y, -1, 1);  // left up
          count += this.checkDirectionAt(x, y, 1, -1);  // right down
          compareAndReset();
          // horizontal
          count += this.checkDirectionAt(x, y, 1, 1);   // right up
          count += this.checkDirectionAt(x, y, -1, -1); // left down
          compareAndReset();
          // positive slant
          count += this.checkDirectionAt(x, y, 0, 1);   // up
          count += this.checkDirectionAt(x, y, 0, -1);  // down
          compareAndReset();
          // vertical
          count += this.checkDirectionAt(x, y, -1, 0);  // left
          count += this.checkDirectionAt(x, y, 1, 0);   // right
          compareAndReset();
          return highestCount >= this.piecesToWin;
        }
        isValidAt(x, y) {
          return x >=0 && x < this.grid[0].length &&
                y >= 0 && y < this.grid.length;
        }
        checkDirectionAt(x1, y1, xDir, yDir) {
          const x2 = x1 + xDir;
          const y2 = y1 + yDir;

          if(this.isValidAt(x1, y1) && this.isValidAt(x2, y2))
            if(this.compareSlotsAt(x1, y1, x2, y2))
              return 1 + this.checkDirectionAt(x2, y2, xDir, yDir);
          return 0;
        }
        setSlotAt(x, y, value, force = false) {
          const slot = this.getSlotAt(x, y);

          if(force || this.getSlotValueAt(x, y) === EMPTY) {
            slot.setAttribute("value", value);
            return this.updateSlot(slot);
          }
          return false;
        }
        compareSlotsAt(x1, y1, x2, y2) {
          if(this.getSlotValueAt(x1, y1) !== EMPTY)
            return this.getSlotValueAt(x1, y1) === this.getSlotValueAt(x2, y2);
          return false;
        }
        getSlotValueAt(x, y) {
          return Number(this.getSlotAt(x, y).getAttribute("value"));
        }
        getSlotAt(x, y) {
          return this.getCellAt(x, y).firstElementChild;
        }
        getCellAt(x, y) {
          return this.grid[y][x];
        }
      };

      var a = new Gameboard(6, 7, 4, 2);
    </script>
  </body>
</html>
